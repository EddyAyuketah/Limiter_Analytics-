This section of my data transformation code is supposed to handle the math on our forecasting and alerts page is there something wrong here? becasue i will like to think that if i set a treshold 
at 30% and have CEIDs that are at 30%, i should be seing them with some level of breakdown of their occurance. 
// Data for forecasting
export const getForecastData = (ceidData, totalCeids) => {
  if (ceidData.length === 0) return [];
  
  // Get current trend for last periods
  const periods = [28, 35, 42, 49, 56, 63, 70, 77, 84];
  const currentData = periods.map(period => ({
    name: `${period}d`,
    value: ceidData.length > 0 
      ? (ceidData.reduce((sum, item) => sum + parseFloat(item[`ABA_PERCENT_FLAGED_${period}DAYS`]), 0) / totalCeids).toFixed(4) 
      : 0
  }));

  
  // Simple linear regression for forecasting
  const xValues = currentData.map((_, i) => i);
  const yValues = currentData.map(d => parseFloat(d.value));
  
  const n = xValues.length;
  const sum_x = xValues.reduce((a, b) => a + b, 0);
  const sum_y = yValues.reduce((a, b) => a + b, 0);
  const sum_xy = xValues.map((x, i) => x * yValues[i]).reduce((a, b) => a + b, 0);
  const sum_xx = xValues.map(x => x * x).reduce((a, b) => a + b, 0);
  
  const slope = (n * sum_xy - sum_x * sum_y) / (n * sum_xx - sum_x * sum_x);
  const intercept = (sum_y - slope * sum_x) / n;
  

  
  // Generate forecast data
  const forecast = [...Array(5)].map((_, i) => {
    const forecastValue = (slope * (n + i) + intercept).toFixed(4);
    return {
      name: `F${i+1}`,
      value: forecastValue > 0 ? forecastValue : 0,
      forecast: true
    };
  });
  
  return [...currentData, ...forecast];
};



// Set up alert thresholds
export const getAlerts = (ceidData, timeRange) => {
  if (ceidData.length === 0) return [];
  
  return ceidData
    .filter(ceid => parseFloat(ceid[`ABA_PERCENT_FLAGED_${timeRange}DAYS`]) > 0.6)
    .sort((a, b) => parseFloat(b[`ABA_PERCENT_FLAGED_${timeRange}DAYS`]) - parseFloat(a[`ABA_PERCENT_FLAGED_${timeRange}DAYS`]))
    .slice(0, 5)
    .map(ceid => ({
      ceid: ceid.CEID,
      area: ceid.AREA,
      percentage: parseFloat(ceid[`ABA_PERCENT_FLAGED_${timeRange}DAYS`]).toFixed(4),
      count: ceid[`ABA_LIMITER_COUNT_${timeRange}DAYS`]
    }));
};

